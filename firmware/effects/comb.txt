#pragma once
#include <math.h>
#include <stdlib.h>
#include "biquad.h"
#include "../platform/circular_buffer.h"

typedef struct
{
    circular_buffer_t buffer;
    biquad_t          filter;
    float             feedback_gain;
    float             filtered;
    float             current_delay_samples;
    float             target_delay_samples;
    float             xfade; // Crossfade amount between old and new delay times
    float old_delay_samples; // Keep track of previous delay for crossfading
    float crossfade_increment;
} comb_t;

void comb_init(comb_t *c, size_t sample_rate)
{
    circular_buffer_init(&c->buffer, (size_t)(0.2f * sample_rate));
    biquad_init(&c->filter, FILTER_LOWPASS, 8000, 0.707f, 1, sample_rate);
    c->feedback_gain         = 0.0f;
    c->filtered              = 0.0f;
    c->current_delay_samples = 0.0f;
    c->target_delay_samples  = 0.0f;
    c->xfade                 = 1.0f;
    c->old_delay_samples     = 0.0f;
    c->crossfade_increment   = 1.0f / (sample_rate * 0.2f); // 50ms crossfade
}

float comb_process(comb_t *c, float input)
{
    // Smoothly approach target delay time
    float delta = c->target_delay_samples - c->current_delay_samples;
    c->current_delay_samples += delta * 0.001f; // Adjust coefficient for smoothing
    
    // If we're changing delay time, crossfade between old and new
    float delayed;

    if(c->xfade < 1.0f)
    {
        // Get sample from old delay time
        int old_read_pos = c->buffer.write_pos - (int)c->old_delay_samples;
        if(old_read_pos < 0)
            old_read_pos += c->buffer.size;
        float old_delayed = circular_buffer_read(&c->buffer, old_read_pos);

        // Get sample from new delay time
        int new_read_pos = c->buffer.write_pos - (int)c->current_delay_samples;
        if(new_read_pos < 0)
            new_read_pos += c->buffer.size;
        float new_delayed = circular_buffer_read(&c->buffer, new_read_pos);

        // Crossfade between them
        delayed = (old_delayed * (1.0f - c->xfade)) + (new_delayed * c->xfade);

        // Update crossfade
        c->xfade
            += c->crossfade_increment; // Use sample-rate dependent increment
    }
    else
    {
        // Normal processing when not changing delay time
        int read_pos = c->buffer.write_pos - (int)c->current_delay_samples;
        if(read_pos < 0)
            read_pos += c->buffer.size;
        delayed = circular_buffer_read(&c->buffer, read_pos);
    }

    // Apply filter and feedback
    float filtered = biquad_process(&c->filter, delayed);
    circular_buffer_write(&c->buffer, input + (filtered * c->feedback_gain));

    return delayed;
}

// Ge the current delay time in seconds
float comb_get_delay(comb_t *c, float sample_rate)
{
    return c->current_delay_samples / sample_rate;
}

// Set delay time in seconds
void comb_set_delay(comb_t *c, float delay_time, float sample_rate)
{
    float new_delay = delay_time * sample_rate;
    if(new_delay >= c->buffer.size)
        new_delay = c->buffer.size - 1;
    if(new_delay < 0)
        new_delay = 0;

    // Only trigger crossfade if delay time is actually changing significantly
    if(fabsf(new_delay - c->current_delay_samples)
       > 1.0f) // Less sensitive threshold
    {
        c->old_delay_samples     = c->current_delay_samples;
        c->current_delay_samples = new_delay;
        c->xfade                 = 0.0f;
    }
    else
    {
        // Small changes can interpolate directly
        c->current_delay_samples = new_delay;
    }
}

// Set feedback amount (0 to 1)
void comb_set_feedback(comb_t *c, float feedback)
{
    c->feedback_gain = feedback;
}

// Set damping amount (0 to 1)
void comb_set_damping(comb_t *c, float damping_freq)
{
    biquad_set_frequency(&c->filter, damping_freq);
}

void comb_clear(comb_t *c)
{
    for(size_t i = 0; i < c->buffer.size; i++)
    {
        circular_buffer_write(&c->buffer, 0.0f);
    }
}