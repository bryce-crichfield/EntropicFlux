#include "arm_math.h"
#include "daisy_seed.h"
#include "daisysp.h"
#define DAISY
#define PLATFORM_DAISY
#include "Button.h"
#include "ShiftRegister.h"
// #include "effects/fdn.h"
// #include "effects/harmonizer.h"
// #include "effects/schroeder.h"

using namespace daisy;
using namespace daisysp;

DaisySeed hw;
// schroeder_t schroeder;
// fdn_t fdn;
// harmonizer_t harmonizer;
// biquad_t tone_filter;

float mix = 0.0f;
float decay = 0.0f;
float modulation_rate = 0.0f;
float damping = 0.0f;
float tone_freq = 0.0f;

bool bypassed = false;
size_t mode = 0;

void AudioCallback(AudioHandle::InputBuffer in, AudioHandle::OutputBuffer out, size_t size) {
    // schroeder_set_decay(&schroeder, decay);
    // schroder_set_modulation_rate(&schroeder, modulation_rate);

    // fdn_set_decay(&fdn, decay);
    // fdn_set_modulation_rate(&fdn, modulation_rate);

    // biquad_set_frequency(&tone_filter, tone_freq);

    for (size_t i = 0; i < size; i++) {
        float input = (in[1][i] + in[0][i]);
        float signal = input;
        // if (bypassed) {
        out[0][i] = out[1][i] = signal;
        // continue;
        return;
        // }

        // switch (mode)
        // {
        // case 0:
        //     signal = harmonizer_process(&harmonizer, signal);
        //     fdn_process(&fdn, signal);
        //     schroeder_process(&schroeder, signal);
        //     break;
        // case 1:
        //     signal = fdn_process(&fdn, signal);
        //     harmonizer_process(&harmonizer, signal);
        //     schroeder_process(&schroeder, signal);
        //     break;
        // case 2:
        //     signal = schroeder_process(&schroeder, signal);
        //     harmonizer_process(&harmonizer, signal);
        //     fdn_process(&fdn, signal);
        //     break;
        // default:
        //     break;
        // }

        // signal = biquad_process(&tone_filter, signal);
        // float output = (input * (1.0f - mix)) + (signal * mix);
        // float output = signal;
        // out[0][i] = out[1][i] = output;
    }
}

int main(void) {
    hw.Configure();
    hw.Init();
    AdcChannelConfig adcConfig[5];
    adcConfig[0].InitSingle(hw.GetPin(15));
    adcConfig[1].InitSingle(hw.GetPin(16));
    adcConfig[2].InitSingle(hw.GetPin(17));
    adcConfig[3].InitSingle(hw.GetPin(18));
    adcConfig[4].InitSingle(hw.GetPin(19));
    hw.adc.Init(adcConfig, 5);
    hw.adc.Start();

    Button bypass_btn;                                                                                                                                                         
    bypass_btn.Init(hw.GetPin(1));

    Button mode_btn;
    mode_btn.Init(hw.GetPin(3));

    // ShiftRegister sr;
    // sr.Init();
    // System::Delay(500);
    // sr.Set(7, true);
    // sr.Set(1, true);
    // sr.Set(2, false);
    // sr.Set(3, true);


    hw.SetAudioBlockSize(256);
    hw.SetAudioSampleRate(SaiHandle::Config::SampleRate::SAI_48KHZ);

    // schroeder_init(&schroeder, hw.AudioSampleRate());
    // schroeder_set_decay(&schroeder, 3.0f);
    // schroeder_set_damping(&schroeder, 0.5f);

    // fdn_init(&fdn, hw.AudioSampleRate());

    // harmonizer_init(&harmonizer, hw.AudioSampleRate());
    // harmonizer_set_harmony(&harmonizer, PERFECT_FIFTH);

    // biquad_init(&tone_filter, FILTER_LOWPASS, 1000, 0.707f, 2, hw.AudioSampleRate());

    // hw.StartAudio(AudioCallback);


    Led test_led;
test_led.Init(daisy::seed::D4, false);  // Test just D4 first

    while(1) {
        test_led.Set(true);
        test_led.Update();
        System::Delay(500);
        test_led.Set(false);
        test_led.Update();
        System::Delay(500);
    }

    while (1) {


        // if (bypass_btn.checkButton()) {
        //     bypassed = !bypassed;
        //     sr.Set(7, !bypassed);
        //     hw.SetLed(!bypassed);
        // }

        // if (mode_btn.checkButton()) {
        //     mode = (mode + 1) % 4;
        //     for (size_t i = 0; i < 4; i++) {
        //         sr.Set(i + 1, false);
        //     }
        //     sr.Set(mode + 1, true);

        //     hw.SetLed(mode);
        // }

        // mix = hw.adc.GetFloat(0);
        // decay = hw.adc.GetFloat(1);
        // decay = 0.1f + (decay * 9.9f);
        // modulation_rate = hw.adc.GetFloat(2);
        // damping = hw.adc.GetFloat(3);

        // tone_freq = hw.adc.GetFloat(4);
        // tone_freq = 1000.0f + (tone_freq * 19000.0f);
    }
}